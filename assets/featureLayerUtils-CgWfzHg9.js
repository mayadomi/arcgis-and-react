import{bz as j,bA as z,q as G,s as y}from"./index-BdlI2FVT.js";import{i as E}from"./originUtils-D69mHv66.js";import{$ as k,w as g,I as x,v as N,j as q,y as B,P as C,l as O,d as V,c as I}from"./utils-BAdo22zH.js";import{p as m,l as F,b,u as $,f as u,i as T}from"./portalItemUtils-CCKlXC6h.js";import{t as H}from"./fetchService-CBugwHAF.js";import{L as Q}from"./layerUtils-C0ByrsCg.js";import{a as W}from"./lazyLayerLoader-B2GRwTGz.js";import"./multiOriginJSONSupportUtils-C0wm8_Yw.js";import"./PortalItem-D_imZ4F9.js";import"./jsonContext-BnRI_b3Y.js";import"./saveAPIKeyUtils-CZD59sVZ.js";import"./saveUtils-BO0eIC9S.js";import"./projection-NmY8Pkrx.js";const h="Feature Service",w="feature-layer-utils",X=`${w}-save`,Z=`${w}-save-as`,p=`${w}-saveall`,f=`${w}-saveall-as`;function v(e){return{isValid:Q(e)&&(e.type!=="feature"||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function J(e){const r=[],a=[];for(const{layer:t,layerJSON:s}of e)t.isTable?a.push(s):r.push(s);return{layers:r,tables:a}}function M(e){return J([e])}async function R(e,r){return/\/\d+\/?$/.test(e.url)?M(r[0]):D(r,e)}async function D(e,r){if(e.reverse(),!r)return J(e);const a=await ee(r,e);for(const t of e)U(t.layer,t.layerJSON,a);return te(a,e),a}async function ee(e,r){let a=await e.fetchData("json");if(re(a))return a;a||(a={}),ae(a);const{layer:{url:t,customParameters:s,apiKey:o}}=r[0];return await ne(a,{url:t??"",customParameters:s,apiKey:o},r.map(n=>n.layer.layerId)),a}function re(e){return!!(e&&Array.isArray(e.layers)&&Array.isArray(e.tables))}function ae(e){e.layers||(e.layers=[]),e.tables||(e.tables=[])}function te(e,r){const a=[],t=[];for(const{layer:s}of r){const{isTable:o,layerId:n}=s;o?t.push(n):a.push(n)}A(e.layers,a),A(e.tables,t)}function A(e,r){if(e.length<2)return;const a=[];for(const{id:t}of e)a.push(t);j(a.sort(L),r.slice().sort(L))&&e.sort((t,s)=>{const o=r.indexOf(t.id),n=r.indexOf(s.id);return o<n?-1:o>n?1:0})}function L(e,r){return e<r?-1:e>r?1:0}async function ne(e,r,a){const{url:t,customParameters:s,apiKey:o}=r,{serviceJSON:n,layersJSON:i}=await H(t,{customParameters:s,apiKey:o}),l=P(e.layers,n.layers,a),c=P(e.tables,n.tables,a);e.layers=l.itemResources,e.tables=c.itemResources;const d=[...l.added,...c.added],_=i?[...i.layers,...i.tables]:[];await oe(e,d,t,_)}function P(e,r,a){const t=z(e,r,(o,n)=>o.id===n.id);e=e.filter(o=>!t.removed.some(n=>n.id===o.id));const s=t.added;return s.forEach(({id:o})=>{e.push({id:o})}),{itemResources:e,added:s.filter(({id:o})=>!a.includes(o))}}async function oe(e,r,a,t){const s=await se(r),o=r.map(({id:n,type:i})=>new(s.get(i))({url:a,layerId:n,sourceJSON:t.find(({id:l})=>l===n)}));await Promise.allSettled(o.map(n=>n.load())),o.forEach(n=>{const{layerId:i,loaded:l,defaultPopupTemplate:c}=n;if(!l||c==null)return;const d={id:i,popupInfo:c.toJSON()};n.operationalLayerType!=="ArcGISFeatureLayer"&&(d.layerType=n.operationalLayerType),U(n,d,e)})}async function se(e){const r=[];e.forEach(({type:s})=>{const o=ie(s),n=W[o];r.push(n())});const a=await Promise.all(r),t=new Map;return e.forEach(({type:s},o)=>{t.set(s,a[o])}),t}function ie(e){let r;switch(e){case"Feature Layer":case"Table":r="FeatureLayer";break;case"Oriented Imagery Layer":r="OrientedImageryLayer";break;case"Catalog Layer":r="CatalogLayer"}return r}function U(e,r,a){e.isTable?S(a.tables,r):S(a.layers,r)}function S(e,r){const a=e.findIndex(({id:t})=>t===r.id);a===-1?e.push(r):e[a]=r}function K(e,r){if(!e.length)throw new y(`${r}:missing-parameters`,"'layers' array should contain at least one feature layer")}function le(e,r){const a=e.map(t=>t.portalItem.id);if(new Set(a).size>1)throw new y(`${r}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function Y(e,r){const a=e.map(t=>t.layerId);if(new Set(a).size!==a.length)throw new y(`${r}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function ce(e){K(e,p),await Promise.all(e.map(r=>r.load()));for(const r of e)O(r,p,v),V({layer:r,itemType:h,errorNamePrefix:p});le(e,p),Y(e,p)}async function ue(e,r){const{url:a,layerId:t,title:s,fullExtent:o,isTable:n}=e,i=m(a);r.url=(i==null?void 0:i.serverType)==="FeatureServer"?a:`${a}/${t}`,r.title||(r.title=s),r.extent=null,n||o==null||(r.extent=await F(o)),b(r,u.METADATA),b(r,u.MULTI_LAYER),T(r,u.SINGLE_LAYER),n&&T(r,u.TABLE)}function ye(e,r){for(const o of e){const n=o.parsedUrl.path,i=m(n);if(!(i==null?void 0:i.url.path))throw new y(`${r}:invalid-parameters`,I(o,`has unsupported url pattern: ${n}`),{layer:o});const c=i==null?void 0:i.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new y(`${r}:invalid-parameters`,I(o,`has unsupported server type: ${c}`),{layer:o});if(c==="MapServer"&&e.length>1)throw new y(`${r}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=m(e[0].parsedUrl.path),t=a==null?void 0:a.url.path;if(!e.every(o=>{const n=m(o.parsedUrl.path);return(n==null?void 0:n.url.path)===t}))throw new y(`${r}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function pe(e){K(e,f),await Promise.all(e.map(r=>r.load()));for(const r of e)O(r,f,v);ye(e,f),Y(e,f)}async function fe(e,r){let a=0,t=0;for(const{isTable:n}of r)n?t++:a++;const s=r[0].parsedUrl.path,o=m(s);if(e.url=(o==null?void 0:o.serverType)==="FeatureServer"?o.url.path:s,e.title||(e.title=o.title),e.extent=null,a>0){const n=r.map(i=>i.fullExtent).filter(G).reduce((i,l)=>i.clone().union(l));n&&(e.extent=await F(n))}b(e,u.METADATA),$(e,u.MULTI_LAYER,r.length>1),$(e,u.SINGLE_LAYER,r.length===1),$(e,u.TABLE,t>0&&a===0),N(e)}async function Ee(e,r){return k({layer:e,itemType:h,validateLayer:v,createItemData:(a,t)=>R(t,[a]),errorNamePrefix:X},r)}async function ge(e,r){await ce(e);const a=e[0].portalItem,t=g(a),s=await Promise.all(e.map(n=>x(n,t,r))),o=await R(a,e.map((n,i)=>({layer:n,layerJSON:s[i]})));return N(a),await a.update({data:o}),await Promise.all(e.slice(1).map(n=>n.portalItem.reload())),E(t),a.clone()}async function xe(e,r,a){return q({layer:e,itemType:h,validateLayer:v,createItemData:(t,s)=>Promise.resolve(M(t)),errorNamePrefix:Z,newItem:r,setItemProperties:ue},a)}async function Ne(e,r,a){await pe(e);const t=B({itemType:h,errorNamePrefix:f,newItem:r}),s=g(t),o=await Promise.all(e.map(i=>x(i,s,a))),n=await D(e.map((i,l)=>({layer:i,layerJSON:o[l]})));await fe(t,e),await C(t,n,a);for(const i of e)i.portalItem=t.clone();return E(s),t}export{Ee as save,ge as saveAll,Ne as saveAllAs,xe as saveAs};

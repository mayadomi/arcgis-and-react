import{cO as X,c0 as C,U as D,ae as Z,I as _,a2 as B,aZ as A,as as N,cs as z,b4 as O,b as E,cr as G,s as H}from"./index-BdlI2FVT.js";import{r as P,o as q,i as w,s as F}from"./normalizeUtilsCommon-Cpq7p5az.js";import{f as K,r as Q,o as V}from"./utils-nisnNviQ.js";async function Y(e,s,a,n){const t=K(e),r=s[0].spatialReference,i={...n,responseType:"json",query:{...t.query,f:"json",sr:X(r),target:JSON.stringify({geometryType:C(s[0]),geometries:s}),cutter:JSON.stringify(a)}},o=await D(t.path+"/cut",i),{cutIndexes:l,geometries:u=[]}=o.data;return{cutIndexes:l,geometries:u.map(p=>{const m=Z(p);return m.spatialReference=r,m})}}async function ee(e,s,a){const n=typeof e=="string"?_(e):e,t=s[0].spatialReference,r=C(s[0]),i={...a,query:{...n.query,f:"json",sr:X(t),geometries:JSON.stringify(Q(s))}},{data:o}=await D(n.path+"/simplify",i);return V(o.geometries,r,t)}const W=()=>E.getLogger("esri.geometry.support.normalizeUtils");function te(e){return e.type==="polygon"}function se(e){return e[0].type==="polygon"}function ne(e){return e[0].type==="polyline"}function k(e){const s=[];let a=0,n=0;for(let t=0;t<e.length;t++){const r=e[t];let i=null;for(let o=0;o<r.length;o++)i=r[o],s.push(i),o===0?(a=i[0],n=a):(a=Math.min(a,i[0]),n=Math.max(n,i[0]));i&&s.push([(a+n)/2,0])}return s}function oe(e,s){if(!(e instanceof N||e instanceof O)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw W().error(t),new H(t)}const a=q(e),n=[];for(const t of a){const r=[];n.push(r),r.push([t[0][0],t[0][1]]);for(let i=0;i<t.length-1;i++){const o=t[i][0],l=t[i][1],u=t[i+1][0],p=t[i+1][1],m=Math.sqrt((u-o)*(u-o)+(p-l)*(p-l)),h=(p-l)/m,x=(u-o)/m,g=m/s;if(g>1){for(let R=1;R<=g-1;R++){const b=R*s,c=x*b+o,f=h*b+l;r.push([c,f])}const $=(m+Math.floor(g-1)*s)/2,j=x*$+o,S=h*$+l;r.push([j,S])}r.push([u,p])}}return te(e)?new O({rings:n,spatialReference:e.spatialReference}):new N({paths:n,spatialReference:e.spatialReference})}function J(e,s,a){if(s){const n=oe(e,1e6);e=G(n,!0)}return a&&(e=F(e,a)),e}function T(e,s,a){if(Array.isArray(e)){const n=e[0];if(n>s){const t=w(n,s);e[0]=n+t*(-2*s)}else if(n<a){const t=w(n,a);e[0]=n+t*(-2*a)}}else{const n=e.x;if(n>s){const t=w(n,s);e=e.clone().offset(t*(-2*s),0)}else if(n<a){const t=w(n,a);e=e.clone().offset(t*(-2*a),0)}}return e}function ie(e,s){let a=-1;for(let n=0;n<s.cutIndexes.length;n++){const t=s.cutIndexes[n],r=s.geometries[n],i=q(r);for(let o=0;o<i.length;o++){const l=i[o];l.some(u=>{if(u[0]<180)return!0;{let p=0;for(let h=0;h<l.length;h++){const x=l[h][0];p=x>p?x:p}p=Number(p.toFixed(9));const m=-360*w(p,180);for(let h=0;h<l.length;h++){const x=r.getPoint(o,h);r.setPoint(o,h,x.clone().offset(m,0))}return!0}})}if(t===a){if(se(e))for(const o of q(r))e[t]=e[t].addRing(o);else if(ne(e))for(const o of q(r))e[t]=e[t].addPath(o)}else a=t,e[t]=r}return e}async function re(e,s,a){if(!Array.isArray(e))return re([e],s);s&&typeof s!="string"&&W().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:(s==null?void 0:s.url)??B.geometryServiceUrl;let t,r,i,o,l,u,p,m,h=0;const x=[],g=[];for(const c of e)if(c!=null)if(t||(t=c.spatialReference,r=A(t),i=t.isWebMercator,u=i?102100:4326,o=P[u].maxX,l=P[u].minX,p=P[u].plus180Line,m=P[u].minus180Line),r)if(c.type==="mesh")g.push(c);else if(c.type==="point")g.push(T(c.clone(),o,l));else if(c.type==="multipoint"){const f=c.clone();f.points=f.points.map(y=>T(y,o,l)),g.push(f)}else if(c.type==="extent"){const f=c.clone()._normalize(!1,!1,r);g.push(f.rings?new O(f):f)}else if(c.extent){const f=c.extent,y=w(f.xmin,l)*(2*o);let d=y===0?c.clone():F(c.clone(),y);f.offset(y,0),f.intersects(p)&&f.xmax!==o?(h=f.xmax>h?f.xmax:h,d=J(d,i),x.push(d),g.push("cut")):f.intersects(m)&&f.xmin!==l?(h=f.xmax*(2*o)>h?f.xmax*(2*o):h,d=J(d,i,360),x.push(d),g.push("cut")):g.push(d)}else g.push(c.clone());else g.push(c);else g.push(c);let $=w(h,o),j=-90;const S=$,R=new N;for(;$>0;){const c=360*$-180;R.addPath([[c,j],[c,-1*j]]),j*=-1,$--}if(x.length>0&&S>0){const c=ie(x,await Y(n,x,R,a)),f=[],y=[];for(let M=0;M<g.length;M++){const v=g[M];if(v!=="cut")y.push(v);else{const L=c.shift(),I=e[M];I!=null&&I.type==="polygon"&&I.rings&&I.rings.length>1&&L.rings.length>=I.rings.length?(f.push(L),y.push("simplify")):y.push(i?z(L):L)}}if(!f.length)return y;const d=await ee(n,f,a),U=[];for(let M=0;M<y.length;M++){const v=y[M];v!=="simplify"?U.push(v):U.push(i?z(d.shift()):d.shift())}return U}const b=[];for(let c=0;c<g.length;c++){const f=g[c];if(f!=="cut")b.push(f);else{const y=x.shift();b.push(i===!0?z(y):y)}}return b}function fe(e){if(!e)return null;const s=e.extent;if(!s)return null;const a=e.spatialReference&&A(e.spatialReference);if(!a)return s;const[n,t]=a.valid,r=2*t,{width:i}=s;let o,{xmin:l,xmax:u}=s;if([l,u]=[u,l],e.type==="extent"||i===0||i<=t||i>r||l<n||u>t)return s;switch(e.type){case"polygon":if(!(e.rings.length>1))return s;o=k(e.rings);break;case"polyline":if(!(e.paths.length>1))return s;o=k(e.paths);break;case"multipoint":o=e.points}const p=s.clone();for(let m=0;m<o.length;m++){let h=o[m][0];h<0?(h+=t,u=Math.max(h,u)):(h-=t,l=Math.min(h,l))}return p.xmin=l,p.xmax=u,p.width<i?(p.xmin-=t,p.xmax-=t,p):s}function ue(e,s,a){const n=A(a);if(n==null)return e;const[t,r]=n.valid,i=2*r;let o=0,l=0;s>r?o=Math.ceil(Math.abs(s-r)/i):s<t&&(o=-Math.ceil(Math.abs(s-t)/i)),e>r?l=Math.ceil(Math.abs(e-r)/i):e<t&&(l=-Math.ceil(Math.abs(e-t)/i));let u=e+(o-l)*i;const p=u-s;return p>r?u-=i:p<t&&(u+=i),u}function pe(e,s){const a=A(s);if(a){const[n,t]=a.valid,r=t-n;if(e<n)for(;e<n;)e+=r;if(e>t)for(;e>t;)e-=r}return e}export{pe as L,ue as P,re as R,fe as v};
